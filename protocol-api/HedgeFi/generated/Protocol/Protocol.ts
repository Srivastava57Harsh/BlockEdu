// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.

import {
  ethereum,
  JSONValue,
  TypedMap,
  Entity,
  Bytes,
  Address,
  BigInt
} from "@graphprotocol/graph-ts";

export class Claim extends ethereum.Event {
  get params(): Claim__Params {
    return new Claim__Params(this);
  }
}

export class Claim__Params {
  _event: Claim;

  constructor(event: Claim) {
    this._event = event;
  }

  get claimant(): Address {
    return this._event.parameters[0].value.toAddress();
  }

  get amount_A(): BigInt {
    return this._event.parameters[1].value.toBigInt();
  }

  get amount_B(): BigInt {
    return this._event.parameters[2].value.toBigInt();
  }

  get amount_c(): BigInt {
    return this._event.parameters[3].value.toBigInt();
  }

  get amount_cx(): BigInt {
    return this._event.parameters[4].value.toBigInt();
  }

  get amount_cy(): BigInt {
    return this._event.parameters[5].value.toBigInt();
  }
}

export class Divest extends ethereum.Event {
  get params(): Divest__Params {
    return new Divest__Params(this);
  }
}

export class Divest__Params {
  _event: Divest;

  constructor(event: Divest) {
    this._event = event;
  }

  get amount_c(): BigInt {
    return this._event.parameters[0].value.toBigInt();
  }

  get amount_cx(): BigInt {
    return this._event.parameters[1].value.toBigInt();
  }

  get amount_cy(): BigInt {
    return this._event.parameters[2].value.toBigInt();
  }

  get amount_c_incentive(): BigInt {
    return this._event.parameters[3].value.toBigInt();
  }
}

export class Invest extends ethereum.Event {
  get params(): Invest__Params {
    return new Invest__Params(this);
  }
}

export class Invest__Params {
  _event: Invest;

  constructor(event: Invest) {
    this._event = event;
  }

  get amount_c(): BigInt {
    return this._event.parameters[0].value.toBigInt();
  }

  get amount_cx(): BigInt {
    return this._event.parameters[1].value.toBigInt();
  }

  get amount_cy(): BigInt {
    return this._event.parameters[2].value.toBigInt();
  }

  get amount_c_incentive(): BigInt {
    return this._event.parameters[3].value.toBigInt();
  }
}

export class RiskSplit extends ethereum.Event {
  get params(): RiskSplit__Params {
    return new RiskSplit__Params(this);
  }
}

export class RiskSplit__Params {
  _event: RiskSplit;

  constructor(event: RiskSplit) {
    this._event = event;
  }

  get splitter(): Address {
    return this._event.parameters[0].value.toAddress();
  }

  get amount_c(): BigInt {
    return this._event.parameters[1].value.toBigInt();
  }
}

export class Protocol extends ethereum.SmartContract {
  static bind(address: Address): Protocol {
    return new Protocol("Protocol", address);
  }

  A(): Address {
    let result = super.call("A", "A():(address)", []);

    return result[0].toAddress();
  }

  try_A(): ethereum.CallResult<Address> {
    let result = super.tryCall("A", "A():(address)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddress());
  }

  B(): Address {
    let result = super.call("B", "B():(address)", []);

    return result[0].toAddress();
  }

  try_B(): ethereum.CallResult<Address> {
    let result = super.tryCall("B", "B():(address)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddress());
  }

  S(): BigInt {
    let result = super.call("S", "S():(uint256)", []);

    return result[0].toBigInt();
  }

  try_S(): ethereum.CallResult<BigInt> {
    let result = super.tryCall("S", "S():(uint256)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  T1(): BigInt {
    let result = super.call("T1", "T1():(uint256)", []);

    return result[0].toBigInt();
  }

  try_T1(): ethereum.CallResult<BigInt> {
    let result = super.tryCall("T1", "T1():(uint256)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  T2(): BigInt {
    let result = super.call("T2", "T2():(uint256)", []);

    return result[0].toBigInt();
  }

  try_T2(): ethereum.CallResult<BigInt> {
    let result = super.tryCall("T2", "T2():(uint256)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  T3(): BigInt {
    let result = super.call("T3", "T3():(uint256)", []);

    return result[0].toBigInt();
  }

  try_T3(): ethereum.CallResult<BigInt> {
    let result = super.tryCall("T3", "T3():(uint256)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  c(): Address {
    let result = super.call("c", "c():(address)", []);

    return result[0].toAddress();
  }

  try_c(): ethereum.CallResult<Address> {
    let result = super.tryCall("c", "c():(address)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddress());
  }

  cPayoutA(): BigInt {
    let result = super.call("cPayoutA", "cPayoutA():(uint256)", []);

    return result[0].toBigInt();
  }

  try_cPayoutA(): ethereum.CallResult<BigInt> {
    let result = super.tryCall("cPayoutA", "cPayoutA():(uint256)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  cPayoutB(): BigInt {
    let result = super.call("cPayoutB", "cPayoutB():(uint256)", []);

    return result[0].toBigInt();
  }

  try_cPayoutB(): ethereum.CallResult<BigInt> {
    let result = super.tryCall("cPayoutB", "cPayoutB():(uint256)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  cx(): Address {
    let result = super.call("cx", "cx():(address)", []);

    return result[0].toAddress();
  }

  try_cx(): ethereum.CallResult<Address> {
    let result = super.tryCall("cx", "cx():(address)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddress());
  }

  cxPayout(): BigInt {
    let result = super.call("cxPayout", "cxPayout():(uint256)", []);

    return result[0].toBigInt();
  }

  try_cxPayout(): ethereum.CallResult<BigInt> {
    let result = super.tryCall("cxPayout", "cxPayout():(uint256)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  cy(): Address {
    let result = super.call("cy", "cy():(address)", []);

    return result[0].toAddress();
  }

  try_cy(): ethereum.CallResult<Address> {
    let result = super.tryCall("cy", "cy():(address)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddress());
  }

  cyPayout(): BigInt {
    let result = super.call("cyPayout", "cyPayout():(uint256)", []);

    return result[0].toBigInt();
  }

  try_cyPayout(): ethereum.CallResult<BigInt> {
    let result = super.tryCall("cyPayout", "cyPayout():(uint256)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  inLiquidMode(): boolean {
    let result = super.call("inLiquidMode", "inLiquidMode():(bool)", []);

    return result[0].toBoolean();
  }

  try_inLiquidMode(): ethereum.CallResult<boolean> {
    let result = super.tryCall("inLiquidMode", "inLiquidMode():(bool)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBoolean());
  }

  isInvested(): boolean {
    let result = super.call("isInvested", "isInvested():(bool)", []);

    return result[0].toBoolean();
  }

  try_isInvested(): ethereum.CallResult<boolean> {
    let result = super.tryCall("isInvested", "isInvested():(bool)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBoolean());
  }

  totalTranches(): BigInt {
    let result = super.call("totalTranches", "totalTranches():(uint256)", []);

    return result[0].toBigInt();
  }

  try_totalTranches(): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "totalTranches",
      "totalTranches():(uint256)",
      []
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  x(): Address {
    let result = super.call("x", "x():(address)", []);

    return result[0].toAddress();
  }

  try_x(): ethereum.CallResult<Address> {
    let result = super.tryCall("x", "x():(address)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddress());
  }
}

export class ConstructorCall extends ethereum.Call {
  get inputs(): ConstructorCall__Inputs {
    return new ConstructorCall__Inputs(this);
  }

  get outputs(): ConstructorCall__Outputs {
    return new ConstructorCall__Outputs(this);
  }
}

export class ConstructorCall__Inputs {
  _call: ConstructorCall;

  constructor(call: ConstructorCall) {
    this._call = call;
  }
}

export class ConstructorCall__Outputs {
  _call: ConstructorCall;

  constructor(call: ConstructorCall) {
    this._call = call;
  }
}

export class ClaimCall extends ethereum.Call {
  get inputs(): ClaimCall__Inputs {
    return new ClaimCall__Inputs(this);
  }

  get outputs(): ClaimCall__Outputs {
    return new ClaimCall__Outputs(this);
  }
}

export class ClaimCall__Inputs {
  _call: ClaimCall;

  constructor(call: ClaimCall) {
    this._call = call;
  }

  get amount_A(): BigInt {
    return this._call.inputValues[0].value.toBigInt();
  }

  get amount_B(): BigInt {
    return this._call.inputValues[1].value.toBigInt();
  }
}

export class ClaimCall__Outputs {
  _call: ClaimCall;

  constructor(call: ClaimCall) {
    this._call = call;
  }
}

export class ClaimACall extends ethereum.Call {
  get inputs(): ClaimACall__Inputs {
    return new ClaimACall__Inputs(this);
  }

  get outputs(): ClaimACall__Outputs {
    return new ClaimACall__Outputs(this);
  }
}

export class ClaimACall__Inputs {
  _call: ClaimACall;

  constructor(call: ClaimACall) {
    this._call = call;
  }

  get tranches_to_cx(): BigInt {
    return this._call.inputValues[0].value.toBigInt();
  }

  get tranches_to_cy(): BigInt {
    return this._call.inputValues[1].value.toBigInt();
  }
}

export class ClaimACall__Outputs {
  _call: ClaimACall;

  constructor(call: ClaimACall) {
    this._call = call;
  }
}

export class ClaimAllCall extends ethereum.Call {
  get inputs(): ClaimAllCall__Inputs {
    return new ClaimAllCall__Inputs(this);
  }

  get outputs(): ClaimAllCall__Outputs {
    return new ClaimAllCall__Outputs(this);
  }
}

export class ClaimAllCall__Inputs {
  _call: ClaimAllCall;

  constructor(call: ClaimAllCall) {
    this._call = call;
  }
}

export class ClaimAllCall__Outputs {
  _call: ClaimAllCall;

  constructor(call: ClaimAllCall) {
    this._call = call;
  }
}

export class ClaimBCall extends ethereum.Call {
  get inputs(): ClaimBCall__Inputs {
    return new ClaimBCall__Inputs(this);
  }

  get outputs(): ClaimBCall__Outputs {
    return new ClaimBCall__Outputs(this);
  }
}

export class ClaimBCall__Inputs {
  _call: ClaimBCall;

  constructor(call: ClaimBCall) {
    this._call = call;
  }

  get tranches_to_cx(): BigInt {
    return this._call.inputValues[0].value.toBigInt();
  }

  get tranches_to_cy(): BigInt {
    return this._call.inputValues[1].value.toBigInt();
  }
}

export class ClaimBCall__Outputs {
  _call: ClaimBCall;

  constructor(call: ClaimBCall) {
    this._call = call;
  }
}

export class DivestCall extends ethereum.Call {
  get inputs(): DivestCall__Inputs {
    return new DivestCall__Inputs(this);
  }

  get outputs(): DivestCall__Outputs {
    return new DivestCall__Outputs(this);
  }
}

export class DivestCall__Inputs {
  _call: DivestCall;

  constructor(call: DivestCall) {
    this._call = call;
  }
}

export class DivestCall__Outputs {
  _call: DivestCall;

  constructor(call: DivestCall) {
    this._call = call;
  }
}

export class InvestCall extends ethereum.Call {
  get inputs(): InvestCall__Inputs {
    return new InvestCall__Inputs(this);
  }

  get outputs(): InvestCall__Outputs {
    return new InvestCall__Outputs(this);
  }
}

export class InvestCall__Inputs {
  _call: InvestCall;

  constructor(call: InvestCall) {
    this._call = call;
  }
}

export class InvestCall__Outputs {
  _call: InvestCall;

  constructor(call: InvestCall) {
    this._call = call;
  }
}

export class SplitRiskCall extends ethereum.Call {
  get inputs(): SplitRiskCall__Inputs {
    return new SplitRiskCall__Inputs(this);
  }

  get outputs(): SplitRiskCall__Outputs {
    return new SplitRiskCall__Outputs(this);
  }
}

export class SplitRiskCall__Inputs {
  _call: SplitRiskCall;

  constructor(call: SplitRiskCall) {
    this._call = call;
  }

  get amount_c(): BigInt {
    return this._call.inputValues[0].value.toBigInt();
  }
}

export class SplitRiskCall__Outputs {
  _call: SplitRiskCall;

  constructor(call: SplitRiskCall) {
    this._call = call;
  }
}
